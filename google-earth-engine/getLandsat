//////////////////////////////////////////////////////////////////////////////////////////////////////////
// getLandsat
//
// This script generates a composite stack of Landsat bands exported as a GEE Asset
//
// Bands Exported: blue, green, red, nir, siwr1, swir2
//
// The composite is made using Landsat 4,5,7, and 8 satellite data of the given date and season range
//
//
// last updated 10/23/23


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Module imports
//GTAC library of functions that are used in this script
var getImageLib = require('users/USFS_GTAC/modules:getImagesLib.js'); //DO NOT CHANGE 

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Define user parameters:

// Study Area (Area of Interest):
//  This is the project area boundary. The studyArea con be a featureCollection, feature, or geometry.
//  Import project area shapefile as an asset to GEE. Then click on that asset to import into the script. 
//  If importing from GEE asset it will come in as table. You can also use the geometry imports to draw 
//  a polygon. This will show up as geometry in the imports section.
var studyArea = table; //geometry; // import by asset (table) or polygon drwaing imports from map (geometry) 

var projectName = 'soils2026-class5-projects'; //project keep as is unless working on a differenct project

var fileName = 'test_mst'; // should include aoi, and season (wet, dry, leafOn, leafOff, etc)

//Specify scale if transform is null
var scale = 30;

//CRS- must be provided.  
//Common crs codes: Web mercator is EPSG:4326, USGS Albers is EPSG:5070, 
//WGS84 UTM N hemisphere is EPSG:326+ zone number (zone 12 N would be EPSG:32612) and S hemisphere is EPSG:327+ zone number
var crs = 'EPSG:5070';

//Specify transform if scale is null and snapping to known grid is needed
var transform =null;// [10,0,-2361915.0,0,-10,3177735.0];

//Specify resample method
var resampleMethod = 'bilinear';
//Update the startJulian and endJulian variables to indicate your seasonal 
//constraints. This supports wrapping for tropics and southern hemisphere.
//startJulian: Starting Julian date 
//endJulian: Ending Julian date
// 0-365 for entire year composite
var startJulian = 0;
var endJulian = 30; 

//Specify start and end years for all analyses
//time span should be an odd number

//More than a 3 year span should be provided for time series methods to work 
//well. If using Fmask as the cloud/cloud shadow masking method, this does not matter
//The date range should be greater than the timebuffer below
var startYear = 2016;
var endYear = 2022;

//Specify an annual buffer to include imagery from the same season 
//timeframe from the prior and following year. timeBuffer = 1 will result 
//in a 3 year moving window

////One composite image stack for the entire date range:
//    The date range should be an odd number: 1999, 2000, 2001 - 3 year date range
//    The timebuffer should be = (Number of Years -1)/2 : for 1999-2001 = (3-1)/2 = 1
//    The timebuffer is a moving window that will composit the image
// For example- if timeBuffer is 1, that is a 3 year moving window
//  If the center year is 2000, then the years are 1999, 2000, and 2001
// For example- if timeBuffer is 3, that 7 year moving window
//  If the center year is 2000, then the years are 1997, 1998, 1999, 2000, 2001, 2002, and 2003
//
////A composite image stack for each year in the date range:
//    The date range should be greater than the timebuffer
//    The timebuffer should be = 1 for a 3 year moving window, or 3 for a 7 year moving window
var timebuffer = 3;

//Specify the weights to be used for the moving window created by timeBuffer
//For example- if timeBuffer is 1, that is a 3 year moving window
//If the center year is 2000, then the years are 1999,2000, and 2001
//In order to overweight the center year, you could specify the weights as
//[1,5,1] which would duplicate the center year 5 times and increase its weight for
//the compositing method
var weights = [1,1,1,1,1,1];

//////////////////////////////////////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Other advanced parameters - these should be left as the default settings for most cases

//Choose medoid or median compositing method. 
//Median tends to be smoother, while medoid retains 
//single date of observation across all bands
//If not exporting indices with composites to save space, medoid should be used
var compositingMethod = 'median';  //

//Choose Top of Atmospheric (TOA) or Surface Reflectance (SR) 
//Specify TOA or SR
//Current implementation does not support Fmask for TOA
var toaOrSR = 'SR';

//Choose whether to include Landat 7
//Generally only included when data are limited
var includeSLCOffL7 = false;

//Whether to defringe L5
//Landsat 5 data has fringes on the edges that can introduce anomalies into 
//the analysis.  This method removes them, but is somewhat computationally expensive
var defringeL5 = true;

//Choose cloud/cloud shadow masking method
//Choices are a series of booleans for cloudScore, TDOM, and elements of Fmask
//Fmask masking options will run fastest since they're precomputed
//CloudScore runs pretty quickly, but does look at the time series to find areas that 
//always have a high cloudScore to reduce comission errors- this takes some time
//and needs a longer time series (>5 years or so)
//TDOM also looks at the time series and will need a longer time series
var applyCloudScore = true;
var applyFmaskCloudMask = true;

var applyTDOM = true;
var applyFmaskCloudShadowMask = true;

var applyFmaskSnowMask = false;

//Cloud and cloud shadow masking parameters.
//If cloudScoreTDOM is chosen
//cloudScoreThresh: If using the cloudScoreTDOMShift method-Threshold for cloud 
//masking (lower number masks more clouds.  Between 10 and 30 generally 
//works best)
var cloudScoreThresh = 10;

//Whether to find if an area typically has a high cloudScore
//If an area is always cloudy, this will result in cloud masking omission
//For bright areas that may always have a high cloudScore
//but not actually be cloudy, this will result in a reduction of commission errors
//This procedure needs at least 5 years of data to work well
var performCloudScoreOffset = true;

//If performCloudScoreOffset = true:
//Percentile of cloud score to pull from time series to represent a minimum for 
//the cloud score over time for a given pixel. Reduces comission errors over 
//cool bright surfaces. Generally between 5 and 10 works well. 0 generally is a
//bit noisy but may be necessary in persistently cloudy areas
var cloudScorePctl = 2.5;

//zScoreThresh: Threshold for cloud shadow masking- lower number masks out 
//less. Between -0.8 and -1.2 generally works well
var zScoreThresh = -1;

//shadowSumThresh: Sum of IR bands to include as shadows within TDOM and the 
//shadow shift method (lower number masks out less)
var shadowSumThresh = 0.35;

//contractPixels: The radius of the number of pixels to contract (negative 
//buffer) clouds and cloud shadows by. Intended to eliminate smaller cloud 
//patches that are likely errors
//(1.5 results in a -1 pixel buffer)(0.5 results in a -0 pixel buffer)
//(1.5 or 2.5 generally is sufficient)
var contractPixels = 1.5; 

//dilatePixels: The radius of the number of pixels to dilate (buffer) clouds 
//and cloud shadows by. Intended to include edges of clouds/cloud shadows 
//that are often missed
//(1.5 results in a 1 pixel buffer)(0.5 results in a 0 pixel buffer)
//(2.5 or 3.5 generally is sufficient)
var dilatePixels = 2.5;

//correctIllumination: Choose if you want to correct the illumination using
//Sun-Canopy-Sensor+C correction. Additionally, choose the scale at which the
//correction is calculated in meters.
var correctIllumination = false;
var correctScale = 250;//Choose a scale to reduce on- 250 generally works well

//Export params
//Whether to export composites
var exportComposites = true;

// End user parameters








//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Start function calls
//
//The functions below originate from users/USFS_GTAC/moduels/getImagesLib.js
//They were modified to print out the composite images clipped to the study area

/////////////////////////////////////////////////////////////////////
var aoi = ee.Geometry(studyArea);
//
var outputName = fileName;
var exportPathRoot = projectName;

// Define visualization parameters
var vizParamsFalse = {
  'min': 0.1, 
  'max': [0.5,0.6,0.6], 
  'bands': 'swir2,nir,red', 
  'gamma': 1.6
};

var vizParamsTrue = {
  'min': 0, 
  'max': [0.2,0.2,0.2], 
  'bands': 'red,green,blue', 
};

// Function to export composite collection
function exportCompositeCollection(exportPathRoot,outputName,studyArea, crs,transform,scale,
collection,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,
nonDivideBands,resampleMethod){
  if(nonDivideBands === undefined || nonDivideBands === null){ nonDivideBands = ['temp']}
  if(resampleMethod === undefined || resampleMethod === null){ resampleMethod = 'bilinear'}
  collection = collection.select(exportBands);
  print('Export bands:',exportBands);
  print('Non divide bands:',nonDivideBands);
   //Take care of date wrapping
  var dateWrapping = getImageLib.wrapDates(startJulian,endJulian);
  var wrapOffset = dateWrapping[0];
  var yearWithMajority = dateWrapping[1];
  
  //Clean up output name
  outputName = outputName.replace(/\s+/g,'-');
  outputName = outputName.replace(/\//g,'-');
  
  
  var years = ee.List.sequence(startYear+timebuffer,endYear-timebuffer).getInfo()
    .map(function(year){
      
    // Set up dates
    var startYearT = year-timebuffer;
    var endYearT = year+timebuffer+yearWithMajority;
    
    // Get yearly composite
    var composite = collection.filter(ee.Filter.calendarRange(year+yearWithMajority,year+yearWithMajority,'year'));
    composite = ee.Image(composite.first());
    
    // Display the Landsat composite
    Map.addLayer(composite.clip(aoi), vizParamsTrue, year.toString() + ' True Color ' + 
      toaOrSR, true);
   // Map.addLayer(composite.clip(aoi), vizParamsFalse, year.toString() + ' False Color ' + 
   //   toaOrSR, false);
  
    // Reformat data for export
    var compositeBands = composite.bandNames();
    if(nonDivideBands !== null){
      var composite10k = composite.select(compositeBands.removeAll(nonDivideBands))
      .multiply(10000);
      composite = composite10k.addBands(composite.select(nonDivideBands))
      .select(compositeBands).int16();
    }
    else{
      composite = composite.multiply(10000).int16();
    }
    
    // Add metadata, cast to integer, and export composite
    composite = composite.set({
      'system:time_start': ee.Date.fromYMD(year,6,1).millis(),
      'source': toaOrSR,
      'yearBuffer':timebuffer,
      'yearWeights': getImageLib.listToString(weights),
      'startJulian': startJulian,
      'endJulian': endJulian,
      'applyCloudScore':applyCloudScore.toString(),
      'applyFmaskCloudMask' :applyFmaskCloudMask.toString(),
      'applyTDOM' :applyTDOM.toString(),
      'applyFmaskCloudShadowMask' :applyFmaskCloudShadowMask.toString(),
      'applyFmaskSnowMask':applyFmaskSnowMask.toString(),
      'compositingMethod': compositingMethod,
      'includeSLCOffL7': includeSLCOffL7.toString(),
      'correctIllumination':correctIllumination.toString(),
      'resampleMethod':resampleMethod});
      
  Export.image.toAsset({
    image: composite.clip(aoi),
    description: 'ls'+'_'+fileName+'_'+toaOrSR+'_'+compositingMethod+'_'+year,
    assetId: 'projects/'+projectName+'/assets/'+'ls'+'_'+fileName+'_'+toaOrSR+'_'+compositingMethod+'_'+year,
    scale: scale,
    maxPixels: 1e13, 
    crs:crs,
    region: studyArea,
  });
});
}

//Wrapper function for getting Landsat imagery
function getLandsatWrapper(studyArea,startYear,endYear,startJulian,endJulian,
  timebuffer,weights,compositingMethod,
  toaOrSR,includeSLCOffL7,defringeL5,applyCloudScore,applyFmaskCloudMask,applyTDOM,
  applyFmaskCloudShadowMask,applyFmaskSnowMask,
  cloudScoreThresh,performCloudScoreOffset,cloudScorePctl,
  zScoreThresh,shadowSumThresh,
  contractPixels,dilatePixels,
  correctIllumination,correctScale,
  exportComposites,outputName,exportPathRoot,
  crs,transform,scale,resampleMethod, 
  preComputedCloudScoreOffset,preComputedTDOMIRMean,preComputedTDOMIRStdDev){
    
    
  if(timebuffer === undefined || timebuffer === null){timebuffer = 0}
  if(weights === undefined || weights === null){weights = [1]}
  if(compositingMethod === undefined || compositingMethod === null){compositingMethod = 'medoid'}
  if(toaOrSR === undefined || toaOrSR === null){toaOrSR = 'SR'}
  if(includeSLCOffL7 === undefined || includeSLCOffL7 === null){includeSLCOffL7 = false}
  if(defringeL5 === undefined || defringeL5 === null){defringeL5 = false}
  if(applyCloudScore === undefined || applyCloudScore === null){applyCloudScore = false}
  if(applyFmaskCloudMask === undefined || applyFmaskCloudMask === null){applyFmaskCloudMask = true}
  if(applyTDOM === undefined || applyTDOM === null){applyTDOM = false}
  if(applyFmaskCloudShadowMask === undefined || applyFmaskCloudShadowMask === null){applyFmaskCloudShadowMask = true}
  if(applyFmaskSnowMask === undefined || applyFmaskSnowMask === null){applyFmaskSnowMask = false}
  if(cloudScoreThresh === undefined || cloudScoreThresh === null){cloudScoreThresh = 10}
  if(performCloudScoreOffset === undefined || performCloudScoreOffset === null){performCloudScoreOffset = true}
  if(cloudScorePctl === undefined || cloudScorePctl === null){cloudScorePctl = 10}
  if(zScoreThresh === undefined || zScoreThresh === null){zScoreThresh = -1}
  if(shadowSumThresh === undefined || shadowSumThresh === null){shadowSumThresh = 0.35}
  if(contractPixels === undefined || contractPixels === null){contractPixels = 1.5}
  if(dilatePixels === undefined || dilatePixels === null){dilatePixels = 3.5}
  if(correctIllumination === undefined || correctIllumination === null){correctIllumination = false}
  if(correctScale === undefined || correctScale === null){correctScale = 250}
  if(exportComposites === undefined || exportComposites === null){exportComposites = false}
  if(outputName === undefined || outputName === null){outputName = 'Landsat-Composite'}
  if(exportPathRoot === undefined || exportPathRoot === null){exportPathRoot = 'users/ianhousman/test'}
  if(crs === undefined || crs === null){crs = 'EPSG:5070'}
  if(resampleMethod === undefined || resampleMethod === null){resampleMethod = 'bilinear'}
  // Prepare dates
  //Wrap the dates if needed
  var wrapOffset = 0;
  if (startJulian > endJulian) {
    wrapOffset = 365;
  }
   
  var startDate = ee.Date.fromYMD(startYear,1,1).advance(startJulian-1,'day');
  var endDate = ee.Date.fromYMD(endYear,1,1).advance(endJulian-1+wrapOffset,'day');
  print('Start and end dates:', startDate, endDate);

  ////Do some error checking
  toaOrSR = toaOrSR.toUpperCase();
  var addPixelQA;
  if(toaOrSR === 'TOA' && (applyFmaskCloudMask === true ||  applyFmaskCloudShadowMask === true || applyFmaskSnowMask === true)){
      addPixelQA = true;
      // applyFmaskCloudMask = false;
  
      // applyFmaskCloudShadowMask = false;
  
      // applyFmaskSnowMask = false;
    }else{addPixelQA = false;}
  // Get Landsat image collection
  var ls = getImageLib.getLandsat(studyArea,startDate,endDate,startJulian,endJulian,
    toaOrSR,includeSLCOffL7,defringeL5,addPixelQA,resampleMethod);
  
  // Apply relevant cloud masking methods
  if(applyCloudScore){
    print('Applying cloudScore');
    ls = getImageLib.applyCloudScoreAlgorithm(ls,getImageLib.landsatCloudScore,cloudScoreThresh,cloudScorePctl,contractPixels,dilatePixels,performCloudScoreOffset, preComputedCloudScoreOffset); 
  }
  
  if(applyFmaskCloudMask){
    print('Applying Fmask cloud mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'cloud')});
    //Experimenting on how to reduce commission errors over bright cool areas
    // var preCount = ls.count();
    // var cloudFreeCount = ls.map(function(img){return cFmask(img,'cloud')}).count().unmask();
    // // var ls = ls.map(function(img){return cFmask(img,'cloud')})
    // var fmaskCloudFreeProp = cloudFreeCount.divide(preCount);
    // var alwaysCloud = fmaskCloudFreeProp.lte(0.1);
    // var ls = ls.map(function(img){
    //   var m = img.select('pixel_qa').bitwiseAnd(fmaskBitDict['cloud']).neq(0).and(alwaysCloud.not());
    //   return img.updateMask(m.not());
    // })
   
    // Map.addLayer(alwaysCloud,{min:0,max:1},'Fmask cloud prop',false);
  }
  
  if(applyTDOM){
    print('Applying TDOM');
    //Find and mask out dark outliers
    ls = getImageLib.simpleTDOM2(ls,zScoreThresh,shadowSumThresh,contractPixels,dilatePixels,['nir','swir1'],preComputedTDOMIRMean,preComputedTDOMIRStdDev);
  }
  if(applyFmaskCloudShadowMask){
    print('Applying Fmask shadow mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'shadow')});
  }
  if(applyFmaskSnowMask){
    print('Applying Fmask snow mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'snow')});
  }
  
  
  // Add zenith and azimuth
  if (correctIllumination){
    ls = ls.map(function(img){
      return addZenithAzimuth(img,toaOrSR);
    });
  }
  
  // Add common indices- can use addIndices for comprehensive indices 
  //or simpleAddIndices for only common indices
  //ls = ls.map(simpleAddIndices)
  //        .map(getTasseledCap)
  //        .map(simpleAddTCAngles);
          
  //Set to appropriate resampling method for any reprojection
  // ls = ls.map(function(img){return img.resample('bicubic') })    
  // Create composite time series
  var ts = getImageLib.compositeTimeSeries(ls,startYear,endYear,startJulian,endJulian,timebuffer,weights,compositingMethod);
  
  
  // Correct illumination
  if (correctIllumination){
    var f = ee.Image(ts.first());
    Map.addLayer(f,vizParamsFalse,'First-non-illuminated',false);
  
    print('Correcting illumination');
    ts = ts.map(illuminationCondition)
      .map(function(img){
        return illuminationCorrection(img, correctScale,studyArea);
      });
    var f = ee.Image(ts.first());
    Map.addLayer(f,vizParamsFalse,'First-illuminated',false);
  }
  
  //Export composites
  if(exportComposites){// Export composite collection
    if(compositingMethod == 'medoid'){
      var exportBands = ['blue', 'green', 'red', 'nir', 'swir1','swir2','temp','year','julianDay'];
      exportCompositeCollection(exportPathRoot,outputName,studyArea,crs,transform,scale,
      ts,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
                  applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,['temp','year','julianDay'],resampleMethod);
    }else{
      var exportBands = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'temp'];
      exportCompositeCollection(exportPathRoot,outputName,studyArea,crs,transform,scale,
      ts,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
                  applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,['temp'],resampleMethod);
    }
  }
  
  return [ls,ts];
}



//Call on master wrapper function to get Landat scenes and composites
var lsAndTs = getLandsatWrapper(studyArea,startYear,endYear,startJulian,endJulian,
  timebuffer,weights,compositingMethod,
  toaOrSR,includeSLCOffL7,defringeL5,applyCloudScore,applyFmaskCloudMask,applyTDOM,
  applyFmaskCloudShadowMask,applyFmaskSnowMask,
  cloudScoreThresh,performCloudScoreOffset,cloudScorePctl,
  zScoreThresh,shadowSumThresh,
  contractPixels,dilatePixels,
  correctIllumination,correctScale,
  exportComposites,outputName,exportPathRoot,crs,transform,scale);

//Separate into scenes and composites for subsequent analysis
var processedScenes = lsAndTs[0];
var processedComposites = lsAndTs[1];

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Map Output


//Load the study region, with a blue outline.
//Create an empty image into which to paint the features, cast to byte.
//Paint all the polygon edges with the same number and width, display.
var empty = ee.Image().byte();
var outline = empty.paint({
  featureCollection: studyArea,
  color: 1,
  width: 3
});
Map.addLayer(outline, {palette: '0000FF'}, "Study Area", true);
Map.centerObject(studyArea);



//var lsScenes = ee.ImageCollection(processedComposites);

//var lsScClip = lsScenes.map(function(lsScenes) { return lsScenes.clip(aoi); });
//print(lsScClip);

  //Take care of date wrapping
    //Iterate across each year and export image
 // ee.List.sequence(startYear+timebuffer,endYear-timebuffer).getInfo()
//    .map(function(year){
//      print('Exporting:',year);
    // Set up dates
//    var startYearT = year-timebuffer;
//    var endYearT = year+timebuffer+yearWithMajority;
  
//Map.addLayer(lsScClip, vizParamsTrue, year.toString() + ' True Color ' , true);
//Map.addLayer(lsScClip, vizParamsFalse, year.toString() + ' False Color ', false);//////////////////////////////////////////////////////////////////////////////////////////////////////////
// getLandsat
//
// This script generates a composite stack of Landsat bands exported as a GEE Asset
//
// Bands Exported: blue, green, red, nir, siwr1, swir2
//
// The composite is made using Landsat 4,5,7, and 8 satellite data of the given date and season range
//
//
// last updated 10/23/23


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Module imports
//GTAC library of functions that are used in this script
var getImageLib = require('users/USFS_GTAC/modules:getImagesLib.js'); //DO NOT CHANGE 

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Define user parameters:

// Study Area (Area of Interest):
//  This is the project area boundary. The studyArea con be a featureCollection, feature, or geometry.
//  Import project area shapefile as an asset to GEE. Then click on that asset to import into the script. 
//  If importing from GEE asset it will come in as table. You can also use the geometry imports to draw 
//  a polygon. This will show up as geometry in the imports section.
var studyArea = table; //geometry; // import by asset (table) or polygon drwaing imports from map (geometry) 

var projectName = 'soils2026-class5-projects'; //project keep as is unless working on a differenct project

var fileName = 'test_mst'; // should include aoi, and season (wet, dry, leafOn, leafOff, etc)

//Specify scale if transform is null
var scale = 30;

//CRS- must be provided.  
//Common crs codes: Web mercator is EPSG:4326, USGS Albers is EPSG:5070, 
//WGS84 UTM N hemisphere is EPSG:326+ zone number (zone 12 N would be EPSG:32612) and S hemisphere is EPSG:327+ zone number
var crs = 'EPSG:5070';

//Specify transform if scale is null and snapping to known grid is needed
var transform =null;// [10,0,-2361915.0,0,-10,3177735.0];

//Specify resample method
var resampleMethod = 'bilinear';
//Update the startJulian and endJulian variables to indicate your seasonal 
//constraints. This supports wrapping for tropics and southern hemisphere.
//startJulian: Starting Julian date 
//endJulian: Ending Julian date
// 0-365 for entire year composite
var startJulian = 0;
var endJulian = 30; 

//Specify start and end years for all analyses
//time span should be an odd number

//More than a 3 year span should be provided for time series methods to work 
//well. If using Fmask as the cloud/cloud shadow masking method, this does not matter
//The date range should be greater than the timebuffer below
var startYear = 2016;
var endYear = 2022;

//Specify an annual buffer to include imagery from the same season 
//timeframe from the prior and following year. timeBuffer = 1 will result 
//in a 3 year moving window

////One composite image stack for the entire date range:
//    The date range should be an odd number: 1999, 2000, 2001 - 3 year date range
//    The timebuffer should be = (Number of Years -1)/2 : for 1999-2001 = (3-1)/2 = 1
//    The timebuffer is a moving window that will composit the image
// For example- if timeBuffer is 1, that is a 3 year moving window
//  If the center year is 2000, then the years are 1999, 2000, and 2001
// For example- if timeBuffer is 3, that 7 year moving window
//  If the center year is 2000, then the years are 1997, 1998, 1999, 2000, 2001, 2002, and 2003
//
////A composite image stack for each year in the date range:
//    The date range should be greater than the timebuffer
//    The timebuffer should be = 1 for a 3 year moving window, or 3 for a 7 year moving window
var timebuffer = 3;

//Specify the weights to be used for the moving window created by timeBuffer
//For example- if timeBuffer is 1, that is a 3 year moving window
//If the center year is 2000, then the years are 1999,2000, and 2001
//In order to overweight the center year, you could specify the weights as
//[1,5,1] which would duplicate the center year 5 times and increase its weight for
//the compositing method
var weights = [1,1,1,1,1,1];

//////////////////////////////////////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Other advanced parameters - these should be left as the default settings for most cases

//Choose medoid or median compositing method. 
//Median tends to be smoother, while medoid retains 
//single date of observation across all bands
//If not exporting indices with composites to save space, medoid should be used
var compositingMethod = 'median';  //

//Choose Top of Atmospheric (TOA) or Surface Reflectance (SR) 
//Specify TOA or SR
//Current implementation does not support Fmask for TOA
var toaOrSR = 'SR';

//Choose whether to include Landat 7
//Generally only included when data are limited
var includeSLCOffL7 = false;

//Whether to defringe L5
//Landsat 5 data has fringes on the edges that can introduce anomalies into 
//the analysis.  This method removes them, but is somewhat computationally expensive
var defringeL5 = true;

//Choose cloud/cloud shadow masking method
//Choices are a series of booleans for cloudScore, TDOM, and elements of Fmask
//Fmask masking options will run fastest since they're precomputed
//CloudScore runs pretty quickly, but does look at the time series to find areas that 
//always have a high cloudScore to reduce comission errors- this takes some time
//and needs a longer time series (>5 years or so)
//TDOM also looks at the time series and will need a longer time series
var applyCloudScore = true;
var applyFmaskCloudMask = true;

var applyTDOM = true;
var applyFmaskCloudShadowMask = true;

var applyFmaskSnowMask = false;

//Cloud and cloud shadow masking parameters.
//If cloudScoreTDOM is chosen
//cloudScoreThresh: If using the cloudScoreTDOMShift method-Threshold for cloud 
//masking (lower number masks more clouds.  Between 10 and 30 generally 
//works best)
var cloudScoreThresh = 10;

//Whether to find if an area typically has a high cloudScore
//If an area is always cloudy, this will result in cloud masking omission
//For bright areas that may always have a high cloudScore
//but not actually be cloudy, this will result in a reduction of commission errors
//This procedure needs at least 5 years of data to work well
var performCloudScoreOffset = true;

//If performCloudScoreOffset = true:
//Percentile of cloud score to pull from time series to represent a minimum for 
//the cloud score over time for a given pixel. Reduces comission errors over 
//cool bright surfaces. Generally between 5 and 10 works well. 0 generally is a
//bit noisy but may be necessary in persistently cloudy areas
var cloudScorePctl = 2.5;

//zScoreThresh: Threshold for cloud shadow masking- lower number masks out 
//less. Between -0.8 and -1.2 generally works well
var zScoreThresh = -1;

//shadowSumThresh: Sum of IR bands to include as shadows within TDOM and the 
//shadow shift method (lower number masks out less)
var shadowSumThresh = 0.35;

//contractPixels: The radius of the number of pixels to contract (negative 
//buffer) clouds and cloud shadows by. Intended to eliminate smaller cloud 
//patches that are likely errors
//(1.5 results in a -1 pixel buffer)(0.5 results in a -0 pixel buffer)
//(1.5 or 2.5 generally is sufficient)
var contractPixels = 1.5; 

//dilatePixels: The radius of the number of pixels to dilate (buffer) clouds 
//and cloud shadows by. Intended to include edges of clouds/cloud shadows 
//that are often missed
//(1.5 results in a 1 pixel buffer)(0.5 results in a 0 pixel buffer)
//(2.5 or 3.5 generally is sufficient)
var dilatePixels = 2.5;

//correctIllumination: Choose if you want to correct the illumination using
//Sun-Canopy-Sensor+C correction. Additionally, choose the scale at which the
//correction is calculated in meters.
var correctIllumination = false;
var correctScale = 250;//Choose a scale to reduce on- 250 generally works well

//Export params
//Whether to export composites
var exportComposites = true;

// End user parameters








//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Start function calls
//
//The functions below originate from users/USFS_GTAC/moduels/getImagesLib.js
//They were modified to print out the composite images clipped to the study area

/////////////////////////////////////////////////////////////////////
var aoi = ee.Geometry(studyArea);
//
var outputName = fileName;
var exportPathRoot = projectName;

// Define visualization parameters
var vizParamsFalse = {
  'min': 0.1, 
  'max': [0.5,0.6,0.6], 
  'bands': 'swir2,nir,red', 
  'gamma': 1.6
};

var vizParamsTrue = {
  'min': 0, 
  'max': [0.2,0.2,0.2], 
  'bands': 'red,green,blue', 
};

// Function to export composite collection
function exportCompositeCollection(exportPathRoot,outputName,studyArea, crs,transform,scale,
collection,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,
nonDivideBands,resampleMethod){
  if(nonDivideBands === undefined || nonDivideBands === null){ nonDivideBands = ['temp']}
  if(resampleMethod === undefined || resampleMethod === null){ resampleMethod = 'bilinear'}
  collection = collection.select(exportBands);
  print('Export bands:',exportBands);
  print('Non divide bands:',nonDivideBands);
   //Take care of date wrapping
  var dateWrapping = getImageLib.wrapDates(startJulian,endJulian);
  var wrapOffset = dateWrapping[0];
  var yearWithMajority = dateWrapping[1];
  
  //Clean up output name
  outputName = outputName.replace(/\s+/g,'-');
  outputName = outputName.replace(/\//g,'-');
  
  
  var years = ee.List.sequence(startYear+timebuffer,endYear-timebuffer).getInfo()
    .map(function(year){
      
    // Set up dates
    var startYearT = year-timebuffer;
    var endYearT = year+timebuffer+yearWithMajority;
    
    // Get yearly composite
    var composite = collection.filter(ee.Filter.calendarRange(year+yearWithMajority,year+yearWithMajority,'year'));
    composite = ee.Image(composite.first());
    
    // Display the Landsat composite
    Map.addLayer(composite.clip(aoi), vizParamsTrue, year.toString() + ' True Color ' + 
      toaOrSR, true);
   // Map.addLayer(composite.clip(aoi), vizParamsFalse, year.toString() + ' False Color ' + 
   //   toaOrSR, false);
  
    // Reformat data for export
    var compositeBands = composite.bandNames();
    if(nonDivideBands !== null){
      var composite10k = composite.select(compositeBands.removeAll(nonDivideBands))
      .multiply(10000);
      composite = composite10k.addBands(composite.select(nonDivideBands))
      .select(compositeBands).int16();
    }
    else{
      composite = composite.multiply(10000).int16();
    }
    
    // Add metadata, cast to integer, and export composite
    composite = composite.set({
      'system:time_start': ee.Date.fromYMD(year,6,1).millis(),
      'source': toaOrSR,
      'yearBuffer':timebuffer,
      'yearWeights': getImageLib.listToString(weights),
      'startJulian': startJulian,
      'endJulian': endJulian,
      'applyCloudScore':applyCloudScore.toString(),
      'applyFmaskCloudMask' :applyFmaskCloudMask.toString(),
      'applyTDOM' :applyTDOM.toString(),
      'applyFmaskCloudShadowMask' :applyFmaskCloudShadowMask.toString(),
      'applyFmaskSnowMask':applyFmaskSnowMask.toString(),
      'compositingMethod': compositingMethod,
      'includeSLCOffL7': includeSLCOffL7.toString(),
      'correctIllumination':correctIllumination.toString(),
      'resampleMethod':resampleMethod});
      
  Export.image.toAsset({
    image: composite.clip(aoi),
    description: 'ls'+'_'+fileName+'_'+toaOrSR+'_'+compositingMethod+'_'+year,
    assetId: 'projects/'+projectName+'/assets/'+'ls'+'_'+fileName+'_'+toaOrSR+'_'+compositingMethod+'_'+year,
    scale: scale,
    maxPixels: 1e13, 
    crs:crs,
    region: studyArea,
  });
});
}

//Wrapper function for getting Landsat imagery
function getLandsatWrapper(studyArea,startYear,endYear,startJulian,endJulian,
  timebuffer,weights,compositingMethod,
  toaOrSR,includeSLCOffL7,defringeL5,applyCloudScore,applyFmaskCloudMask,applyTDOM,
  applyFmaskCloudShadowMask,applyFmaskSnowMask,
  cloudScoreThresh,performCloudScoreOffset,cloudScorePctl,
  zScoreThresh,shadowSumThresh,
  contractPixels,dilatePixels,
  correctIllumination,correctScale,
  exportComposites,outputName,exportPathRoot,
  crs,transform,scale,resampleMethod, 
  preComputedCloudScoreOffset,preComputedTDOMIRMean,preComputedTDOMIRStdDev){
    
    
  if(timebuffer === undefined || timebuffer === null){timebuffer = 0}
  if(weights === undefined || weights === null){weights = [1]}
  if(compositingMethod === undefined || compositingMethod === null){compositingMethod = 'medoid'}
  if(toaOrSR === undefined || toaOrSR === null){toaOrSR = 'SR'}
  if(includeSLCOffL7 === undefined || includeSLCOffL7 === null){includeSLCOffL7 = false}
  if(defringeL5 === undefined || defringeL5 === null){defringeL5 = false}
  if(applyCloudScore === undefined || applyCloudScore === null){applyCloudScore = false}
  if(applyFmaskCloudMask === undefined || applyFmaskCloudMask === null){applyFmaskCloudMask = true}
  if(applyTDOM === undefined || applyTDOM === null){applyTDOM = false}
  if(applyFmaskCloudShadowMask === undefined || applyFmaskCloudShadowMask === null){applyFmaskCloudShadowMask = true}
  if(applyFmaskSnowMask === undefined || applyFmaskSnowMask === null){applyFmaskSnowMask = false}
  if(cloudScoreThresh === undefined || cloudScoreThresh === null){cloudScoreThresh = 10}
  if(performCloudScoreOffset === undefined || performCloudScoreOffset === null){performCloudScoreOffset = true}
  if(cloudScorePctl === undefined || cloudScorePctl === null){cloudScorePctl = 10}
  if(zScoreThresh === undefined || zScoreThresh === null){zScoreThresh = -1}
  if(shadowSumThresh === undefined || shadowSumThresh === null){shadowSumThresh = 0.35}
  if(contractPixels === undefined || contractPixels === null){contractPixels = 1.5}
  if(dilatePixels === undefined || dilatePixels === null){dilatePixels = 3.5}
  if(correctIllumination === undefined || correctIllumination === null){correctIllumination = false}
  if(correctScale === undefined || correctScale === null){correctScale = 250}
  if(exportComposites === undefined || exportComposites === null){exportComposites = false}
  if(outputName === undefined || outputName === null){outputName = 'Landsat-Composite'}
  if(exportPathRoot === undefined || exportPathRoot === null){exportPathRoot = 'users/ianhousman/test'}
  if(crs === undefined || crs === null){crs = 'EPSG:5070'}
  if(resampleMethod === undefined || resampleMethod === null){resampleMethod = 'bilinear'}
  // Prepare dates
  //Wrap the dates if needed
  var wrapOffset = 0;
  if (startJulian > endJulian) {
    wrapOffset = 365;
  }
   
  var startDate = ee.Date.fromYMD(startYear,1,1).advance(startJulian-1,'day');
  var endDate = ee.Date.fromYMD(endYear,1,1).advance(endJulian-1+wrapOffset,'day');
  print('Start and end dates:', startDate, endDate);

  ////Do some error checking
  toaOrSR = toaOrSR.toUpperCase();
  var addPixelQA;
  if(toaOrSR === 'TOA' && (applyFmaskCloudMask === true ||  applyFmaskCloudShadowMask === true || applyFmaskSnowMask === true)){
      addPixelQA = true;
      // applyFmaskCloudMask = false;
  
      // applyFmaskCloudShadowMask = false;
  
      // applyFmaskSnowMask = false;
    }else{addPixelQA = false;}
  // Get Landsat image collection
  var ls = getImageLib.getLandsat(studyArea,startDate,endDate,startJulian,endJulian,
    toaOrSR,includeSLCOffL7,defringeL5,addPixelQA,resampleMethod);
  
  // Apply relevant cloud masking methods
  if(applyCloudScore){
    print('Applying cloudScore');
    ls = getImageLib.applyCloudScoreAlgorithm(ls,getImageLib.landsatCloudScore,cloudScoreThresh,cloudScorePctl,contractPixels,dilatePixels,performCloudScoreOffset, preComputedCloudScoreOffset); 
  }
  
  if(applyFmaskCloudMask){
    print('Applying Fmask cloud mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'cloud')});
    //Experimenting on how to reduce commission errors over bright cool areas
    // var preCount = ls.count();
    // var cloudFreeCount = ls.map(function(img){return cFmask(img,'cloud')}).count().unmask();
    // // var ls = ls.map(function(img){return cFmask(img,'cloud')})
    // var fmaskCloudFreeProp = cloudFreeCount.divide(preCount);
    // var alwaysCloud = fmaskCloudFreeProp.lte(0.1);
    // var ls = ls.map(function(img){
    //   var m = img.select('pixel_qa').bitwiseAnd(fmaskBitDict['cloud']).neq(0).and(alwaysCloud.not());
    //   return img.updateMask(m.not());
    // })
   
    // Map.addLayer(alwaysCloud,{min:0,max:1},'Fmask cloud prop',false);
  }
  
  if(applyTDOM){
    print('Applying TDOM');
    //Find and mask out dark outliers
    ls = getImageLib.simpleTDOM2(ls,zScoreThresh,shadowSumThresh,contractPixels,dilatePixels,['nir','swir1'],preComputedTDOMIRMean,preComputedTDOMIRStdDev);
  }
  if(applyFmaskCloudShadowMask){
    print('Applying Fmask shadow mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'shadow')});
  }
  if(applyFmaskSnowMask){
    print('Applying Fmask snow mask');
    ls = ls.map(function(img){return getImageLib.cFmask(img,'snow')});
  }
  
  
  // Add zenith and azimuth
  if (correctIllumination){
    ls = ls.map(function(img){
      return addZenithAzimuth(img,toaOrSR);
    });
  }
  
  // Add common indices- can use addIndices for comprehensive indices 
  //or simpleAddIndices for only common indices
  //ls = ls.map(simpleAddIndices)
  //        .map(getTasseledCap)
  //        .map(simpleAddTCAngles);
          
  //Set to appropriate resampling method for any reprojection
  // ls = ls.map(function(img){return img.resample('bicubic') })    
  // Create composite time series
  var ts = getImageLib.compositeTimeSeries(ls,startYear,endYear,startJulian,endJulian,timebuffer,weights,compositingMethod);
  
  
  // Correct illumination
  if (correctIllumination){
    var f = ee.Image(ts.first());
    Map.addLayer(f,vizParamsFalse,'First-non-illuminated',false);
  
    print('Correcting illumination');
    ts = ts.map(illuminationCondition)
      .map(function(img){
        return illuminationCorrection(img, correctScale,studyArea);
      });
    var f = ee.Image(ts.first());
    Map.addLayer(f,vizParamsFalse,'First-illuminated',false);
  }
  
  //Export composites
  if(exportComposites){// Export composite collection
    if(compositingMethod == 'medoid'){
      var exportBands = ['blue', 'green', 'red', 'nir', 'swir1','swir2','temp','year','julianDay'];
      exportCompositeCollection(exportPathRoot,outputName,studyArea,crs,transform,scale,
      ts,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
                  applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,['temp','year','julianDay'],resampleMethod);
    }else{
      var exportBands = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2', 'temp'];
      exportCompositeCollection(exportPathRoot,outputName,studyArea,crs,transform,scale,
      ts,startYear,endYear,startJulian,endJulian,compositingMethod,timebuffer,exportBands,toaOrSR,weights,
                  applyCloudScore, applyFmaskCloudMask,applyTDOM,applyFmaskCloudShadowMask,applyFmaskSnowMask,includeSLCOffL7,correctIllumination,['temp'],resampleMethod);
    }
  }
  
  return [ls,ts];
}



//Call on master wrapper function to get Landat scenes and composites
var lsAndTs = getLandsatWrapper(studyArea,startYear,endYear,startJulian,endJulian,
  timebuffer,weights,compositingMethod,
  toaOrSR,includeSLCOffL7,defringeL5,applyCloudScore,applyFmaskCloudMask,applyTDOM,
  applyFmaskCloudShadowMask,applyFmaskSnowMask,
  cloudScoreThresh,performCloudScoreOffset,cloudScorePctl,
  zScoreThresh,shadowSumThresh,
  contractPixels,dilatePixels,
  correctIllumination,correctScale,
  exportComposites,outputName,exportPathRoot,crs,transform,scale);

//Separate into scenes and composites for subsequent analysis
var processedScenes = lsAndTs[0];
var processedComposites = lsAndTs[1];

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Map Output


//Load the study region, with a blue outline.
//Create an empty image into which to paint the features, cast to byte.
//Paint all the polygon edges with the same number and width, display.
var empty = ee.Image().byte();
var outline = empty.paint({
  featureCollection: studyArea,
  color: 1,
  width: 3
});
Map.addLayer(outline, {palette: '0000FF'}, "Study Area", true);
Map.centerObject(studyArea);



//var lsScenes = ee.ImageCollection(processedComposites);

//var lsScClip = lsScenes.map(function(lsScenes) { return lsScenes.clip(aoi); });
//print(lsScClip);

  //Take care of date wrapping
    //Iterate across each year and export image
 // ee.List.sequence(startYear+timebuffer,endYear-timebuffer).getInfo()
//    .map(function(year){
//      print('Exporting:',year);
    // Set up dates
//    var startYearT = year-timebuffer;
//    var endYearT = year+timebuffer+yearWithMajority;
  
//Map.addLayer(lsScClip, vizParamsTrue, year.toString() + ' True Color ' , true);
//Map.addLayer(lsScClip, vizParamsFalse, year.toString() + ' False Color ', false);
